## Collatz Conjecture

第一步，将单次加优化为每次加成 y 的倍数，使得 x 相当于每次 ÷ y，$log_y$ 时间内使得 x 变为 1 ;

第二步，当 x 变为 1 时，如果此时还有 k 次操作，$x = 1 + k \; \% \; (y - 1) $  

因为 x 的变化是一个循环节。

## C

DP 做的，这个做法非常好想。

可以写起来麻烦一点，贪心处理 > r 和 $l\leq x\leq r$ 的情况，对于 $l< x$ 的情况，双指针放到 `vector` 里面预处理出来最多的合法段。

dp[i][0/1] 表示是否选择 i （选了就以 i 结尾）

dp[i][0] = max(dp[i - 1][0], dp[i - 1][1])

dp[i][1] = max(dp[p - 1][0], dp[p - 1][1]) + 1

p 是最靠近 i 的满足 s[p - i] >= l && s[p - i] <= r 的点

## D

偏简单，考察二维前缀和模板和裴蜀定理概念。


