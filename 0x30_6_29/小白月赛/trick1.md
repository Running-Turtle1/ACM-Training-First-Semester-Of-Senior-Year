## 题目描述

给一个 $n\times m$ 矩阵迷宫， 第 $i$ 行第 $j$ 列的值为 $c_{i,j}$ ，$LH$ 在迷宫中迷路了，他需要你的帮助。  

$LH$ 当前在 $(1,1)$ 的位置，出口在 $(n,m)$，这个迷宫有一个计数器，只有当计数器的值模 $(p-1)$ 的余数为 $0$ 时迷宫出口才会开门（出口没有开门意味着即使在 $(n,m)$ 的位置也不能逃出去）。  

$LH$ 每一秒会向迷宫的上下左右四个方向走一步（不可以不走），并且不能走出迷宫的边界，假设 $LH$ 从 $(i,j)$ 走到了 $(i',j')$，然后计数器将会加上 $c_{i',j'}$。  

特别的，计数器初始是 $c_{1,1}$。  

$c_{i,j}=a_{i,j}\times p^{2^{b_{i,j}}}$。  

现在 $LH$ 问你，他最快需要多久才可以走出迷宫。

## 输入描述

> 第一行输出三个整数 $n,m,p(1\le n,m\le 10,2\le p\le 10^4)$。 
> 接下来输入一个 $n$ 行 $m$ 列的矩阵 $a_{i,j}$。 
> 接下来输入一个 $n$ 行 $m$ 列的矩阵 $b_{i,j}$。 
> $0\le a_i,b_i\le 10^6$。

## 做法

- 注意到要在模 p-1 意义下，因为 $a^b\%p=(a\%p)^b\%p$ ，所以 $c_{i,j}=a_{i,j}\%(p-1)$ 

- 如此走一遍 bfs 即可

## Trick

- 这题如此简单，那么为什么要放到 trick 专栏呢

- 注意下面代码 :
  
  ```cpp
  void Show(){
      while(q.size()){
      	// auto &[x, y, v] = q.front(); q.pop();
      	auto [x, y, v] = q.front(); q.pop();
      	// cout << x << ' ' << y << ' ' << v << ' ' << d[x][y][v] << '\n';
      	for(int i = 0; i < 4; i ++){
      		int a = x + dx[i];
      		int b = y + dy[i];
      		if(a >= 1 && a <= n && b >= 1 && b <= m){
      			int tmpV = (v + A[a][b]) % (p - 1);
      			if(d[a][b][tmpV] == -1){
      				d[a][b][tmpV] = d[x][y][v] + 1;
      				q.push({a, b, tmpV});
      			}
      		}
      	}
      }
  }
  ```

- 可以看到，这是一个带 pop 的数据结构，这种数据结构进行结构化绑定的时候一定不要加 `&` ，虽然现在看很 NT，但是写的时候就是容易注意不到，所以放到 trick 专栏里面
