# 球盒模型

在做算法题的过程中，很多**计数类问题**的很多情况可以转化为如下**模型**：

n个**相同/不同**的球放到k个**相同/不同**的盒子中，盒子**允许/不允许**为空，问有多少种方案。

## 模型

划分方式如下 ：小球是否有标号为 1/0，盒子是否有标号为 1/0，盒子是否必须放球为 1/0

例如，对于模型4，有 $(100)_2=4$ ，表示：n个**有标号**的球放到k个**无标号**的盒子中，盒子**并非必须放球**。

### 模型0

> n个**无标号**的球放到k个**无标号**的盒子中，盒子**允许为空**。

容易得到当没有球时（n=0）方案数为1，当没有盒子时（k=0）方案为0。

考虑递归求解。易得递归边界为 $b_0(0,k)=1,b(n,0)=0$ ，注意此处没有球的优先级高于没有箱子。

当 $n<k$ 时，必然存在  k-n 个盒子为空，因为盒子是相同的，所以空出来哪些盒子是无所谓的。所以我们可以缩小问题规模：$ b_{0}(n,k)=b_{0}(n,n)$ 

当 $n\ge k$ 时，因为所有盒子都是相同的，所以我们只需要讨论有几个箱子是空的，而不需要具体讨论空的是哪些箱子。

- 没有箱子为空的时，将k个箱子每个都放入一个球，方案数为 $b_{0}(n-k,k)$ 
- 至少一个箱子为空时，先钦定一个箱子为空，方案数为 $b_{0}(n,k-1)$ 

于是我们就可以得到如下代码：

```cpp
int b0(int n, int k)
{
    if(n == 0)
        return 1;
    if(k == 0)
        return 0;
    if(n < k)
        return b0(n, n);
    else 
        return b0(n - k, k) + b0(n, k - 1);
}
```

### 模型1

> n个**无标号**的球放到k个**无标号**的盒子中，盒子**不允许为空**。

模型1跟模型0的差别在于盒子是否可以为空，只需在每个盒子中都先放置一个小球，保证了非空，然后任意放置剩下的球。

这样也就可以将模型1转化为模型0，方案数为 $b_1(n,k)=b_0(n-k,k)$。

需要注意 $n<k$ 时方案数量为0。

```cpp
int b1(int n, int k)
{
    if(n < k)
        return 0;
    else 
        return b0(n - k, k);
}
```

### 模型2：隔板法（插板法）

> n个**无标号**的球放到k个**有标号**的盒子中，盒子**允许为空**。  
> 本质：$x_1+x_2+\cdots+x_k=n$ 的非负整数解的组数。

也就是最经典的**隔板法**。因为球是相同的，我们只需要考虑每个箱子放几个球即可。

将n个球排成一行，然后拿出k-1块木板，将木板插在球的前面或者后面，允许多个木板紧挨着。然后第i(i>1)个木板到第i-1个木板之间的球，当作第i个盒子内球的数量，若没有球则认为第i个盒子为空。特别地，第1块木板前的球当作第1个箱子的球的数量，第k-1块木板之后的球当作第k个箱子的球的数量。

木板是相同的，球也是相同的。每种木板的放置方法，对应一种放球方案。

木板和球都看成“物品”，总共有n+k-1个物品，相当于从中选择出k-1个物品，让它们成为木板。

故总的方案数为 $b_2(n,k)=\dbinom {n+k-1} {k-1}$ 

```cpp
const int N = 1005, md = 1e9 + 7;
LL c[N][N];
void initC() {
    //预处理组合数
    c[0][0] = 1;
    LL R = N - 5;
    for(int i = 1; i <= R; i ++ )
    {
        c[i][0] = 1;
        for(int j = 1; j <= i; j ++)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % md;
    }
}

int b2(int n, int k)
{
    return c[n + k - 1][k - 1];
}
```

### 模型3

> n个**无标号**的球放到k个**有标号**的盒子中，盒子**不允许为空**。  
> 本质：$x_1+x_2+\cdots+x_k=n$ 的正整数解的组数。

对比模型2，区别在于盒子是否能为空。

同样的方法，将n个球排成一行，然后拿出k-1块木板。

不过因为此处盒子不允许为空，所以需要只能插在球与球之间的间隔，且木板不能相邻。

也就是在 n-1个球与球的间隔中，选择 k-1个插入木板

故总的方案数为 $b_3(n,k)=\binom {n-1}{k-1}$ 

```cpp
const int N = 1005, md = 1e9 + 7;
LL c[N][N];
void initC(){
    //预处理组合数
    c[0][0] = 1;
    LL R = N - 5;
    for(int i = 1; i <= R; i ++ )
    {
        c[i][0] = 1;
        for(int j = 1; j <= i; j ++)
            c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % md;
    }
}

int b3(int n, int k)
{
    return c[n - 1][k - 1];
}
```

### 模型4

> n个**有标号**的球放到k个**无标号**的盒子中，盒子**允许为空**。

前置知识：请先阅读 模型5（斯特林子集数）

模型4和模型5的差别，在于本处盒子允许为空。

从斯特林子集数的角度来考虑。因为盒子是相同的，所以我们枚举空了几个盒子就行：$b_4(n,k)=\sum_{i=0}^{k-1} {n\brace k - i}$ 

- 预处理斯特林数的复杂度为 $O(n\times k)$，求和复杂度为 $O(k)$。

```cpp
LL S[N][K];
void initS2() {
    //预处理斯特林数
    S[0][0] = 1;
    for(int i = 1; i < N; i ++ )
        for(int j = 1; j < K; j ++)
            S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * j % md) % md;
}

int b4(int n, int k)
{
    LL res = 0;
    for(int i = 0; i <= k - 1; i ++)
        res = (res + S[n][k - i]) % md;
    return res;
}
```

特别地，当 $n\le k$ 时，答案即为贝尔数（$\text{Bell}$数）。箱子是相同的，故不需要考虑空出来的是哪些箱子。即 $ b_4(n,k)=B_n$ 

对于贝尔数，有如下递推式 $B_{n+1}=\sum_{k=0}^n \binom n k B_k$。我们可以通过这个式子来构造出贝尔三角形，类似“杨辉三角形”，因为二者都含有组合数。构造出来的每行的首项，就是贝尔数，即 $b_4(n,k)=B_n=\text{bell[n+1][1]}$。

**关于如何构造贝尔三角形用于求贝尔数 ：**

用以下方法构造一个三角矩阵（形式类似杨辉三角形，这里叫做贝尔三角形）：

- $a_{1,1}=1$ 
- 对于 $n\geq 1$ ，第 n 行首项等于上一行的末项，即 $a_{n,1}=a_{n-1,n-1}$ ；其余项等于它左边和左上角两个数之和，即 $a_{n,m}=a_{n,m-1}+a_{n-1,m-1}$ 

我们尝试展开贝尔三角形的首项，发现如下规律 (以 $a_{4,1}$ 为例) :

$$
\begin{align*}
a_{4,1} & = a_{3,3} \\
        & = a_{3,2} + a_{2,2} \\
        & =  a_{3,1} + 2*a_{2,1}+a_{1,1}
\end{align*}
$$

 发现最后展开之后，每一项对应某一个首项，它们的系数等同于杨辉三角的系数。数学表达式如下 ：

$a_{n,1}=\sum_{k=0}^{n-2}\binom{n-2}{k}a_{k+1,1}$  

写出 $a_{n,2}$ 的式子之后，对比两个式子，

$a_{n+2,1}=\sum_{k=0}^{n}\binom{n}{k}a_{k+1,1}$  

$B_{n+1}=\sum_{k=0}^n \binom n k B_k$ 

可以发现，$a_{n+1,1}=B_n$ 

- 预处理贝尔数的复杂度为 $\mathcal O(n^2)$，直接拿取答案输出为 $\mathcal O(1)$ 

```cpp
const int N = 2000 + 5;
int bell[N][N];

void initBell(int n) { // 构造贝尔三角形
  bell[1][1] = 1;
  for (int i = 2; i <= n; i++) {
    bell[i][1] = bell[i - 1][i - 1];
    for (int j = 2; j <= i; j++)
      bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1];
  }
}

int B(int n){ // 返回贝尔数
  return bell[n + 1][1];
}
```

### 模型5：斯特林子集数

> n个**有标号**的球放到k个**无标号**的盒子中，盒子**不允许为空**。

即第二类斯特林数$ {n \brace k}$（斯特林子集数）。

- 将n个不同的元素，划分为k个非空子集的方案数。

考虑动态规划，假设目前已有k个集合，对于一个新来的数，一种是加入到已有的k个集合，另一种是这个数单独创建一个集合。所以有：

${n \brace k}={n-1 \brace k-1}+{n-1 \brace k}\times k$。

预处理斯特林数的复杂度为 $O(n\times k)$。答案即为$b_5(n,k)={n\brace k}$

```cpp
LL S[N][N];
void initS2()
{//预处理斯特林数
    S[0][0] = 1;
    int R = N - 5;
    for(int i = 1; i <= R; i ++ )
        for(int j = 1; j <= R; j ++)
            S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * j % md) % md;
}

int b5(int n, int k)
{
    return S[n][k];
}
```

### 模型6

> n个**有标号**的球放到k个**有标号**的盒子中，盒子**允许为空**。

因为盒子可以看成一个无序集合（内部不区分顺序），所以可以单独考虑每个球去哪个盒子，两两之间相互独立。每个球有k种选择，共n个球

故总的方案数为 $b_6(n,k)=k^n$ 

```cpp
LL fpow(LL a, int b)
{
    LL res = 1;
    while(b)
    {
        if(b & 1)
            res = res * a % md;
        a = a * a % md;
        b >>= 1;
    }
    return res;
}

int b6(int n, int k)
{
    return fpow(k, n);
}
```

### 模型7

> n个**有标号**的球放到k个**有标号**的盒子中，盒子**不允许为空**。

对比模型5（斯特林子集数），差别在于该盒子是否相同。

首先应该满足 $n\geq k$ ，然后我们将 n 个球划分为 k 个非空集合，相当于求第二类斯特林子集数，再对 k 个集合做全排列即可。

故总的方案数为 $b_7={n \brace k}\times k!$ 

```cpp
LL S[N][N], fac[N];
void init()
{//预处理斯特林数
    S[0][0] = 1, fac[0] = 1;
    int R = N - 5;
    for(int i = 1; i <= R; i ++ )
        for(int j = 1; j <= R; j ++)
            S[i][j] = (S[i - 1][j - 1] + S[i - 1][j] * j % md) % md;
    for(int i = 1; i <= R; i ++ )
        fac[i] = fac[i - 1] * i % md;
}

int b7(int n, int k)
{
    return S[n][k] * fac[k];
}
```

## 拓展模型 （未看未整理）

约定拓展模型标号，包含原本模型是哪个（用数字表示），以及是第几个拓展模型（用大写字母表示）

### 模型1A

> n个**无标号**的球放到k个**无标号**的盒子中，盒子**不允许为空**。每个盒子里**至少**有t个球。

考虑动态规划，也就是整数分拆了，约定dp_{n,k,t}为将整数n分拆为k个数相加，每个数至少为t的方案数。

有状态转移方程：dp_{n,k,t}=\sum_{i=t}^n dp_{n-i,k-1,i}

- 从n中先划分出一个数i，然后剩余部分n-i划分成k-1个数相加，每个数至少为i。
- 这样方案是不会**计算重复**的，那么为什么**不能是**剩余部分n-i的划分是每个部分至少t呢？这样看似好像也符合答案？
- 我们假设某种将n分解为k个数的方案为：x_1,x_2,\cdots,x_k，其中满足x_i\le x_{i+1}，也就是满足无序集合的要求。
- 假设我们单独划分出x_1，那么x_2,x_3,\cdots,x_k是剩余部分的划分，满足每个数至少为x_1
- 假设我们单独划分出x_2，那么x_1,x_3,\cdots,x_k是剩余部分的划分，满足每个数至少为x_1
- 于是，如果转移方程右边，让剩余部分划分每部分至少为t，会使得x_1,x_2,\cdots,x_k这个方案被**重复计算**，所以不行。
- 但是，划分了i出去之后，约定了每个划分的最小的数为i，这样就保证了一个序列只会被统计一次，毕竟每个划分序列中的最小值**有且仅有一个**

注意递归边界为：

- n<k\times t时，明显不够分了，所以此时方案数为0
- 当k=0时，显然分为0个数相加是不可能的，方案为0
- 当k=1时，一个数就是一个分解方案，方案为1

代码采用记忆化搜索完成

```cpp
LL dp[N][N][N];
        LL dfs(int n, int k, int t)
        {
            if(n < k * t)
                return 0;
            if(k == 0)
                return dp[n][k][t] = 0;
            if(k == 1)
                return dp[n][k][t] = 1;
            if(~dp[n][k][t])
                return dp[n][k][t];
            dp[n][k][t] = 0;
            for(int i = t; i <= n; i ++ )
            {
                if(k * i > n)
                    break;
                dp[n][k][t] += dfs(n - i, k - 1, i);
                dp[n][k][t] %= md;
            }
            return dp[n][k][t];
        }

        int main()
        {
            memset(dp, -1, sizeof dp);
            int n, k, t;
            cin >> n >> k >> t;
            cout << dfs(n, k, t);
        }
```

### 模型2A

> n个**无标号**的球放到k个**有标号**的盒子中，盒子**允许为空**。a_1,\cdots,a_k是给定的非负整数的数组，要求第i个盒子中至少含有a_k个球。  
> 本质：x_1+x_2+\cdots+x_k=n且x_i\ge a_i的非负整数解的组数。

和模型2的差别在于，每个盒子有最少球数的限制，我们尝试去扣除掉这个限制，我们现往每个盒子中放置a_i个球，然后我们就可以任意放置球了，也就把问题又转化为了模型2。

还剩余n-\sum_{i=1}^k a_i个球，依旧为k-1块板子，隔板法公式得最后答案为\binom {n-(\sum_{i=1}^k a_i)+k-1}{k-1}

### 模型2B

> n个**无标号**的球放到k个**有标号**的盒子中，盒子**允许为空**。每个盒子里**至多**t个球。

考虑生成函数。

- 不会生成函数的同学，可以走传送门：[GhostLX：算法学习笔记(5)：生成函数](https://zhuanlan.zhihu.com/p/600776343)

易得答案序列的生成函数为F(x)=(1+x+x^2+\cdots+x^t)^k

由引文中的式1：\sum_{i= 0}^{n}x^{ki}=\cfrac{1-x^{kn+k}}{1-x^{k}}得（该式中的k=1,n=t）

1+x+x^2+\cdots+x^t=\cfrac{1-x^{t+1}}{1-x}

所以有

\begin{eqnarray}F(x)&=&(\cfrac{1-x^{t+1}}{1-x})^k\\&=&(1-x^{t+1})^k\cfrac{1}{(1-x)^k}\\\end{eqnarray}

二项式定理有：

(1-x^{t+1})^k=\sum_{i=0}^k \binom k i (-1)^ix^{(t+1)i}

广义二项式定理有：

\begin{eqnarray}\cfrac{1}{(1-x)^k}&=&(1-x)^{-k}\\&=&\sum_{j=0}^{+\infty}\cfrac{-k(-k-1)(-k-2)\cdots(-k-j+1)}{j!}(-x)^j\\&=&\sum_{j=0}^{+\infty}\cfrac{k(k+1)(k+2)\cdots(k+j-1)}{j!}x^j\\&=&\sum_{j=0}^{+\infty}\binom {k+j-1}{j}x^j\\\end{eqnarray}

考虑两个式子的卷积，枚举第一个式子的求和下标i，其对应幂次方为(t+1)i，那么另一边的幂次方就应该为n-(t+1)i，有因为其原式子求和下标的下界为0，故需要满足n-(t+1)i>0，即i\le \lfloor \cfrac{n}{t+1}\rfloor。有因为第一个式子本身求和终点的限制，所以有i\le \min(k,\lfloor \cfrac{n}{t+1}\rfloor)

所以最后的答案为：

[x^n]F(x)=\sum_{i=0}^{\min(k,\lfloor \frac{n}{t+1}\rfloor)} (-1)^i\binom k i \binom {k+n-(t+1)i-1}{n-(t+1)i}

### 模型2C

> n个**无标号**的球放到k个**有标号**的盒子中，盒子**允许为空**。每个盒子里最多有1个小球，且非空的盒子不能相邻。

容易得到2\times n-1\le k时才有解（考虑极端情况，一隔一），其余情况方案数量均为0

1. 先取出n个盒子排成一行，每个箱子放入一个球。剩余k-n个盒子。

2. 然后在每两个盒子之间插入一个空盒子，还剩下k-2n+1个盒子。

3. 接着我们将剩余的k-2n+1个盒子插入到“带球盒子”之间，共n-1个间隔，加上最前面和最后面一共n+1个位置可以插入盒子。  

4. 此处为什么不能带上**步骤2**中的所有盒子，变成2n-2个间隔？因为那些盒子的作用**仅仅是为了防止非空盒子相邻**，而两个空盒子相连的情况，会在一个空盒子插入到2的某个空盒子前面、后面，被重复计算了两次，所以是行不通的。

5. 我们将**步骤3**中梳理一下，无标号的盒子k-2n+1个，有标号的间隔（位置）为n+1个，允许间隔（位置为空）。然后我们将“盒子”看成“球”，将“间隔（位置）”看成“盒子”这不就是隔板法（模型2）吗？故方案数为\binom {(k-2n+1)+(n+1)-1}{(n+1)-1}=\binom {k-n+1}{n}

故最后的答案为\binom{k-n+1}{n}。
