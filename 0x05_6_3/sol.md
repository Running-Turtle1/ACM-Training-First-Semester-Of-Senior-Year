#### 思路

可以注意到，若n为奇数，则先手只需要将任意一个石头拿空，即可必胜。

如果n为偶数，则需判断最小值的数量，在最小值是奇数的情况下，先手是必胜的，否则后手必胜。

#### 来自验题人的思考过程

如果有一堆石子变成了0，那么剩下的操作每次都只能拿走一整堆石头这样就只需要看非0的石头堆数了。

如果有奇数堆的石头，那么Yukimi可以先手把其中一堆变成0，这样剩下偶数堆非0的石头堆，LCF必败。

---

如果有偶数堆的石头,且有一堆的数目为1，Yukimi必不能先把一堆拿完，否则就鸡了,那么Yukimi只能考虑将目前非1的石头堆掌成1，偶数堆的局面留给LCF，LCF也是一样的操作。比如1 1 3 4。

首先Yukimi操作变成1 1 1 4或者1 1 3 1，LCF操作变成1 1 1 1，随后局面就确定了那么相当于:最小是1的偶数堆情况下，有奇数堆非1的，Yumiki必胜，反之LCF必胜。

---

如果偶数堆所有的石头堆都大于1，Yumiki不能将某一堆石头变成1，这样的话会把奇数堆非1必胜的局面留给LCF相当于谁先把某一堆石头变成1他就必败了，因此都要去避免这个局面。那么也就只能是，尽可能把非最小石头堆变成最小石头堆，最后变成所有堆石头一样的局面。接下来只需要考虑所有石头堆数一样，但是非1的情况了如果这时候都是2，那么就会遇到必败局面；把一堆石头变成1，局面也确定了如果都是3，必定先变成一个2，总共偶数次操作变成全2仍为必败态。由此可以判定:如果所有数都一样，肯定是必败态那么就需要看怎么能到达这个局面了,很显然就是数和最小值不一样的个数，这与前面有1的情况一样。

作者：CoiKX  
链接：[2024宁波大学程序设计竞赛题解_牛客网](https://www.nowcoder.com/discuss/626530853384970240?sourceSSR=users)  
来源：牛客网

---

我至少应该注意到，那一堆石子，必须把他那成最小值，如果有 0，必须全拿走

---

```cpp
hint1 : 
if n is odd number,
    First is winner !
```

如果 n 是偶数，

必然不能拿光

---

真是一道博弈论究极好题，善 ！

---

[D-小黑的区间_牛客周赛 Round 45 (nowcoder.com)](https://ac.nowcoder.com/acm/contest/84244/D)

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long

int const N = 1e5 + 10;
int n, k;
int a[N], p[N], s[N];

void solve(){
    cin >> n >> k;
    for(int i = 1; i <= n; i ++){
        cin >> a[i];
    }
    int res = 0; 
    // j 表示待检查的位置
    p[a[1]] = 1;
    s[a[1]] ++;
    for(int i = 1, j = 2; i <= n; i ++){
        // if(p[a[i]] != 0 && i - p[a[i]] > k) continue; // 不合法
        while(j <= n && (p[a[j]] == 0 || j - p[a[j]] <= k)){
            p[a[j]] = j;
            s[a[j]] ++;
            j ++;
        }
        res += j - i;
        if(-- s[a[i]] == 0) {
            p[a[i]] = 0;
        }
//         cout << i << ' ' << j - 1 << '\n';
    }
    cout << res;
}

// 5 5 9 1 10 1 8 8 2 5 
// 1 9
// 2 10
// 3 10
// 4 10
// 5 10
// 6 10
// 7 10
// 8 10
// 9 10
// 10 10

signed main(){
    ios::sync_with_stdio(false);
    cin.tie(0), cout.tie(0); 
    solve();
    return 0;
}
```

居然被这么一道简单傻逼且无趣的题硬控了，实际上，s[a[i]] == 0, 的时候，才能清空 p 位置，真有点 。。。。
